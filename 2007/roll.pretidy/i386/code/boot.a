INCLUDE real.h

use16
        org 100h

        cmp b[80h], 01
        ja >s1
        jmp error

s1:     call unrealmode                 ; let's use all of memory
                                        ; also sets GateA20 line
        call countmemory
       push eax

        xor bx, bx
        mov es, bx
        
        mov cs:w[dosip], offset backtodos
        mov cs:w[dosip+2], cs

        xor cx, cx                      ; cx = bytes left on cmd line
        mov cl, [80h]

        mov bx, cx
        add bx, 81h
        mov b[bx], 0                    ; make cmd line ASCIIZ

        xor ebx, ebx                    ; bx = number of files loaded
        mov edi, 100000h                ; where kernel expects to be loaded

        mov esi, 82h
sp1:    jcxz parms
        lodsb
        dec cx
        cmp al, ' '
        jz sp1                         ; pass over leading spaces

        mov dx, si                      ; es:dx = *filename
        dec dx

        cmp al, '-'                     ; parm flag?
        jz parms
sp2:    cmp al, 0                       ; end of input?
        jz sp3
        cmp al, ' '
        jz sp3
        lodsb
        loop sp2

sp3:
        mov b[si-1], 0

        call readfile                   ; returns eax = size of file

        mov edx, ftab
        mov [ebx*8+edx], edi            ; char *location
        mov [ebx*8+edx+4], eax          ; int size
        inc ebx

        add eax, 1000h
        and ax, 0f000h                  ; and eax, 0fffff000h

        add edi, eax
        jmp sp1

parms:  ; esi = *parms
       mov edx, ftab
       mov d[ebx*8+edx], 0
       mov d[ebx*8+edx+4], 0

       dec si
       pop edx

        mov eax, ds
        shl eax, 4

        add esi, eax                    ; esi = *parms
        mov ebp, ftab
        add ebp, eax                    ; ebp = *objlist

        add cs:d[GDT+2], eax            ; adjust GDT location

        add cs:d[ch1], eax              ; adjust jmp kCS:prot
        add cs:d[ch2], eax              ; adjust jmp kCS16:c16

        ; 100000h is loader/kernel

        ; start the move to 32-bit protected mode

        mov ecx, edx                    ; ![ ecx = number of dwords to
        shr ecx, 12                     ;    clear for boot page tables
        mov edi, 90000h                 ; page tables start at 90000h
        add ecx, 1000h/4                ; plus page directory

        xor eax, eax

l0:     mov es:d[edi], eax              ; clear pagedir and pagetables
        add edi, 4
        loop l0                         ; rep stosd

        mov ebx, 90000h

        mov ecx, edx
        sub ecx, 1000h                  ; don't do first 4k (NULL refs)

        shr ecx, 12                     ; number of pages in memory
        mov eax, 1003h                  ; R/W, present (1003h)
        mov edi, 1004h                  ; 1004h

l1:     mov es:d[ebx + edi], eax        ; fill all of the page tables
        add eax, 1000h
        add edi, 4
        loop l1

        mov ecx, edx
        shr ecx, 22                     ; number of 4MB chunks in memory
        inc ecx
        mov eax, 91003h                 ; 91003h
        mov edi, 0

l2:     mov es:d[ebx+edi], eax          ; now for the page directory
        mov es:d[ebx+edi+0f00h], eax    ; and map it onto 0xf0000000 too
        add eax, 1000h
        add edi, 4
        loop l2                         

        mov es:d[ebx+0ffch], 90003h     ; identity map page directory

        cmp es:d[100000h], 464c457fh    ; '\07fELF'
        jz elf
        cmp es:d[100000h], 0107h
        jz aout
        jmp error
aout:   mov ebx, es:d[100014h]
        jmp goprot
elf:    mov ebx, es:d[100018h]        ; ELF start amount
;        jmp goprot

goprot: pushfd
        push ds, es, fs, gs

        mov cs:d[oldsp], esp
        mov cs:w[oldsp+4], ss

        pushd 0002h
        popfd

        lgdt cs:[GDT]

        mov eax, 90000h                 ; !
        mov cr3, eax                    ; !

        mov eax, 8000_0001h             ; PE and PG bits
        mov cr0, eax

        ; jmp far kernel_init (kCS:0)
        db 066h, 0eah
ch1:    dd offset prot
        dw 08                           ; kCS

prot:   use32
; here, ebx should be set to the virtual starting point
        mov eax, 10h
        mov ds, ax
        mov es, ax
        mov fs, ax
        mov gs, ax

        mov eax, 18h
        mov ss, ax

        mov eax, 90000h - 4
        mov esp, eax

        push ebp                        ; objlist to load and run
        push esi                        ; *parms
        push edx                        ; amount of memory

        call ebx                        ; ebx = starting point of ucboot
        cli                             ; just in case
        add esp, 12

        db 0eah                         ; far jmp to 16-bit segment
ch2:    dd offset c16
        dw 20h                          ; kCS16

c16:    use16
        mov eax, 28h                    ; kSS16
        mov ss, ax

        mov eax, 0
        mov cr0, eax

        db 0eah                         ; far jmp to real mode
dosip:  dw offset backtodos             ; these are filled in earlier
        dw 0

backtodos:
        mov ax, cs
        mov ds, ax

        mov d[IDT+2], 0h
        lidt [IDT]

        mov ss, w[oldsp+4]
        mov esp, d[oldsp]

        pop gs, fs, es, ds
        popfd

        mov ax, 4c00h
        int 21h                         ; quit to DOS

IDT     dw      07ffh
        dd      0000h

GDTlen  equ 6*8
;       SegDesc b1,Base, Limit[0..15], Type1, T2[4..7], Limit[16..19]
GDT     dw      0ffffh
        dd      offset GDT    ; to be adjusted to real physical location
        dw      0

        SegDesc  00, 0000h,0ffff,10011010xb,0Cfh,0      ; kCS  (08h) CPL0
        SegDesc  00, 0000h,0ffff,10010010xb,0cfh,0      ; kDS  (10h)
        SegDesc  00, 0000h,0ffff,10010010xb,0cfh,0      ; kSS  (18h)
        SegDesc  00, 0000h,0ffff,10011010xb,8fh, 0      ; kCS16 (20h)
        SegDesc  00, 0000h,0ffff,10010010xb,8fh,0       ; kSS16 (28h)
        SegDesc  00, 0000h,0ffff,11111010xb,0cfh,0      ; aCS
        SegDesc  00, 0000h,0ffff,11110010xb,0cfh,0      ; aDS
        SegDesc  00, 0000h,0ffff,11110010xb,0cfh,0      ; aSS

kernelfn db 'os.elf',0

readfile:
; ds:dx = *filename
; es:edi = *where to stick it
        push edi, edi
        push ebx, ecx, edx, esi, ds

        mov ax, 3d02h
        int 21h                         ; open file at fn
        jc error
        mov bx, ax                      ; ax = file handle

r1:     mov ds, cs
        mov dx, buf
        mov ah, 3fh
        mov cx, 2048                    ; try to read 4k
        int 21h                         ; read file
        jc error

        mov esi, buf
        xor ecx, ecx
        mov cx, ax
        rep movs b[esi], b[edi]         ; make sure we're using esi/edi :)
        cmp ax, 2048
        jz r1

        mov ah, 3eh
        int 21h                         ; close file

        pop ds, esi, edx, ecx, ebx
        pop eax
        sub eax, edi
        neg eax                         ; eax = size of file
        pop edi
        ret

error:
        mov dx, offset errmsg
        mov ds, cs
        mov ah, 09
        int 21h
        mov ax, 4c01h
        int 21h

countmemory:
; assumes GateA20 is set, returns eax = amount of memory in bytes
        push ebx, edx, edi, ds

        mov ax, 0
        mov ds, ax

        mov eax, '1234'                 ; signature
        mov ebx, 10_0ff0h               ; assume 1MB at least

b0:     mov edx, d[ebx]
        mov d[ebx], eax                 ; set signature

        mov edi, d[ebx]
        mov d[ebx], edx                 ; restore old value

        cmp edi, eax                    ; see if signature was stored
        jnz >b1

        add ebx, 1000h                  ; 1 page at a time
        jmp b0

b1:
        mov eax, ebx
        sub eax, 1000h                  ; ! 2000h
        add eax, 10h

        pop ds, edi, edx, ebx
        ret

INCLUDE unreal.a

errmsg  db 'Error reading file.$',0
oldsp   dw ?, ?, ?
ftab    equ $
buf     equ $ + 32*4                   ; only 16 files can be loaded here

